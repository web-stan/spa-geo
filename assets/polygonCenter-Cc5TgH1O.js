function C(t,i,n={}){const r={type:"Feature"};return(n.id===0||n.id)&&(r.id=n.id),n.bbox&&(r.bbox=n.bbox),r.properties=i||{},r.geometry=t,r}function G(t,i,n={}){if(!t)throw new Error("coordinates is required");if(!Array.isArray(t))throw new Error("coordinates must be an Array");if(t.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!E(t[0])||!E(t[1]))throw new Error("coordinates must contain numbers");return C({type:"Point",coordinates:t},i,n)}function L(t,i,n={}){for(const e of t){if(e.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");if(e[e.length-1].length!==e[0].length)throw new Error("First and last Position are not equivalent.");for(let o=0;o<e[e.length-1].length;o++)if(e[e.length-1][o]!==e[0][o])throw new Error("First and last Position are not equivalent.")}return C({type:"Polygon",coordinates:t},i,n)}function E(t){return!isNaN(t)&&t!==null&&!Array.isArray(t)}function M(t,i,n){if(t!==null)for(var r,e,o,s,P,f,h,y=0,a=0,b,p=t.type,v=p==="FeatureCollection",k=p==="Feature",A=v?t.features.length:1,c=0;c<A;c++){h=v?t.features[c].geometry:k?t.geometry:t,b=h?h.type==="GeometryCollection":!1,P=b?h.geometries.length:1;for(var w=0;w<P;w++){var l=0,u=0;if(s=b?h.geometries[w]:h,s!==null){f=s.coordinates;var g=s.type;switch(y=0,g){case null:break;case"Point":if(i(f,a,c,l,u)===!1)return!1;a++,l++;break;case"LineString":case"MultiPoint":for(r=0;r<f.length;r++){if(i(f[r],a,c,l,u)===!1)return!1;a++,g==="MultiPoint"&&l++}g==="LineString"&&l++;break;case"Polygon":case"MultiLineString":for(r=0;r<f.length;r++){for(e=0;e<f[r].length-y;e++){if(i(f[r][e],a,c,l,u)===!1)return!1;a++}g==="MultiLineString"&&l++,g==="Polygon"&&u++}g==="Polygon"&&l++;break;case"MultiPolygon":for(r=0;r<f.length;r++){for(u=0,e=0;e<f[r].length;e++){for(o=0;o<f[r][e].length-y;o++){if(i(f[r][e][o],a,c,l,u)===!1)return!1;a++}u++}l++}break;case"GeometryCollection":for(r=0;r<s.geometries.length;r++)if(M(s.geometries[r],i)===!1)return!1;break;default:throw new Error("Unknown Geometry Type")}}}}}function S(t,i={}){if(t.bbox!=null&&i.recompute!==!0)return t.bbox;const n=[1/0,1/0,-1/0,-1/0];return M(t,r=>{n[0]>r[0]&&(n[0]=r[0]),n[1]>r[1]&&(n[1]=r[1]),n[2]<r[0]&&(n[2]=r[0]),n[3]<r[1]&&(n[3]=r[1])}),n}function m(t,i={}){const n=S(t),r=(n[0]+n[2])/2,e=(n[1]+n[3])/2;return G([r,e],i.properties,i)}var q=m;const N=t=>{const i=t.map(s=>[s.lng,s.lat]),n=L([[...i]]),r=q(n),[e,o]=r.geometry.coordinates;return{lat:o,lon:e}};export{N as getPolygonCenter};
